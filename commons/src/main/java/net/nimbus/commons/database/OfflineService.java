package net.nimbus.commons.database;

import com.google.common.util.concurrent.ListenableFuture;
import lombok.extern.slf4j.Slf4j;
import net.nimbus.commons.Commons;
import net.nimbus.commons.cache.Cache;
import net.nimbus.commons.database.query.Result;

import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.List;
import java.util.Optional;
import java.util.function.Predicate;

@Slf4j
public abstract class OfflineService<K, T> extends AbstractService<K, T> {

    public OfflineService() {
        super(new Cache<>());
    }

    public ListenableFuture<Optional<T>> queryAsynchronously(String query, Object... parameters) {
        return Commons.getInstance().getExecutorService().submit(() -> query(query, parameters));
    }

    /**
     * @return list of rows
     */
    public Result sqlQuery(String query, Object... parameters) {
        try (PreparedStatement preparedStatement = Commons.getInstance().getConnection().prepareStatement(query)) {
            for (int i = 0; i < parameters.length; i++) {
                preparedStatement.setObject(i + 1, parameters[i]);
            }
            return new Result(preparedStatement.executeQuery());
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public PreparedStatement buildPreparedStatement(String sql, Object... parameters) {
        PreparedStatement preparedStatement = null;
        try {
            preparedStatement = Commons.getInstance().getConnection().prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);

            for (int i = 0; i < parameters.length; i++) {
                preparedStatement.setObject(i + 1, parameters[i]);
            }

        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
        return preparedStatement;
    }

    /**
     * @return generated ID (primary key) of the entity
     */

    public Long sqlWrite(String sql, Object... parameters) {
        Long generatedKey = -1L;
        try {
            PreparedStatement statement = buildPreparedStatement(sql, parameters);
            statement.execute();

            Result result = new Result(statement.getGeneratedKeys());
            if (!result.isEmpty()) {
                generatedKey = result.getFirstRow().getLong("GENERATED_KEY");
            }

            statement.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }

        return generatedKey;
    }

    public void createNew(K identifier, T object) {
        if (object instanceof LongIdentifierEntity) return;
        insertInternal(object);
        updateCache(identifier, object);
        log.info("successfully created and cached: id: {} object: {}", identifier, object.toString());
    }

    /**
     * @param object Should only be used with entities of identification type Long (LongIdentifierEntity)
     */
    public void createNew(T object) {
        if (!(object instanceof LongIdentifierEntity)) return;
        LongIdentifierEntity entity = (LongIdentifierEntity) object;

        Commons.getInstance().getExecutorService().execute(() -> {
            Long key = insertInternal(object);
            entity.setId(key);
            updateCache((K) key, (T) entity);
            log.info("successfully created and cached: id: {} object: {}", key, object.toString());
        });
    }

    /**
     * @return should return the identifier (most likely the autogenerated key)
     */
    protected abstract Long insertInternal(T object);

    public abstract void update(T object);

    public void persistAll() {
        for (T entity : getCache().getMap().values()) {
            update(entity);
        }
    }
}
